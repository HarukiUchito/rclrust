initSidebarItems({"constant":[["RCL_DEFAULT_DOMAIN_ID",""],["RCL_ENCLAVE_FLAG",""],["RCL_EXTERNAL_LOG_CONFIG_FLAG",""],["RCL_LOG_EXT_LIB_FLAG_SUFFIX",""],["RCL_LOG_LEVEL_FLAG",""],["RCL_LOG_ROSOUT_FLAG_SUFFIX",""],["RCL_LOG_STDOUT_FLAG_SUFFIX",""],["RCL_NODE_OPTIONS_DEFAULT_DOMAIN_ID",""],["RCL_PARAM_FILE_FLAG",""],["RCL_PARAM_FLAG",""],["RCL_REMAP_FLAG",""],["RCL_RET_ALREADY_INIT",""],["RCL_RET_ALREADY_SHUTDOWN",""],["RCL_RET_BAD_ALLOC",""],["RCL_RET_CLIENT_INVALID",""],["RCL_RET_CLIENT_TAKE_FAILED",""],["RCL_RET_ERROR",""],["RCL_RET_EVENT_INVALID",""],["RCL_RET_EVENT_TAKE_FAILED",""],["RCL_RET_INVALID_ARGUMENT",""],["RCL_RET_INVALID_LOG_LEVEL_RULE",""],["RCL_RET_INVALID_PARAM_RULE",""],["RCL_RET_INVALID_REMAP_RULE",""],["RCL_RET_INVALID_ROS_ARGS",""],["RCL_RET_MISMATCHED_RMW_ID",""],["RCL_RET_NODE_INVALID",""],["RCL_RET_NODE_INVALID_NAME",""],["RCL_RET_NODE_INVALID_NAMESPACE",""],["RCL_RET_NODE_NAME_NON_EXISTENT",""],["RCL_RET_NOT_INIT",""],["RCL_RET_OK",""],["RCL_RET_PUBLISHER_INVALID",""],["RCL_RET_SERVICE_INVALID",""],["RCL_RET_SERVICE_NAME_INVALID",""],["RCL_RET_SERVICE_TAKE_FAILED",""],["RCL_RET_SUBSCRIPTION_INVALID",""],["RCL_RET_SUBSCRIPTION_TAKE_FAILED",""],["RCL_RET_TIMEOUT",""],["RCL_RET_TIMER_CANCELED",""],["RCL_RET_TIMER_INVALID",""],["RCL_RET_TOPIC_NAME_INVALID",""],["RCL_RET_UNKNOWN_SUBSTITUTION",""],["RCL_RET_UNSUPPORTED",""],["RCL_RET_WAIT_SET_EMPTY",""],["RCL_RET_WAIT_SET_FULL",""],["RCL_RET_WAIT_SET_INVALID",""],["RCL_RET_WRONG_LEXEME",""],["RCL_ROS_ARGS_EXPLICIT_END_TOKEN",""],["RCL_ROS_ARGS_FLAG",""],["RCL_SHORT_ENCLAVE_FLAG",""],["RCL_SHORT_PARAM_FLAG",""],["RCL_SHORT_REMAP_FLAG",""],["RCUTILS_ERROR_FORMATTING_CHARACTERS",""],["RCUTILS_ERROR_MESSAGE_MAX_LENGTH",""],["RCUTILS_ERROR_STATE_FILE_MAX_LENGTH",""],["RCUTILS_ERROR_STATE_LINE_NUMBER_STR_MAX_LENGTH",""],["RCUTILS_ERROR_STATE_MESSAGE_MAX_LENGTH",""],["RCUTILS_FAULT_INJECTION_FAIL_NOW",""],["RCUTILS_FAULT_INJECTION_NEVER_FAIL",""],["RCUTILS_LOGGING_SEPARATOR_CHAR",""],["RCUTILS_LOGGING_SEPARATOR_STRING",""],["RCUTILS_RET_BAD_ALLOC",""],["RCUTILS_RET_ERROR",""],["RCUTILS_RET_HASH_MAP_NO_MORE_ENTRIES",""],["RCUTILS_RET_INVALID_ARGUMENT",""],["RCUTILS_RET_LOGGING_SEVERITY_MAP_INVALID",""],["RCUTILS_RET_LOGGING_SEVERITY_STRING_INVALID",""],["RCUTILS_RET_NOT_ENOUGH_SPACE",""],["RCUTILS_RET_NOT_FOUND",""],["RCUTILS_RET_NOT_INITIALIZED",""],["RCUTILS_RET_OK",""],["RCUTILS_RET_STRING_KEY_NOT_FOUND",""],["RCUTILS_RET_STRING_MAP_ALREADY_INIT",""],["RCUTILS_RET_STRING_MAP_INVALID",""],["RCUTILS_RET_WARN",""],["RMW_DEFAULT_DOMAIN_ID",""],["RMW_GID_STORAGE_SIZE",""],["RMW_QOS_POLICY_DEPTH_SYSTEM_DEFAULT",""],["RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_NODE_DEPRECATED_MSG",""],["RMW_RET_BAD_ALLOC",""],["RMW_RET_ERROR",""],["RMW_RET_INCORRECT_RMW_IMPLEMENTATION",""],["RMW_RET_INVALID_ARGUMENT",""],["RMW_RET_NODE_NAME_NON_EXISTENT",""],["RMW_RET_OK",""],["RMW_RET_TIMEOUT",""],["RMW_RET_UNSUPPORTED",""]],"enum":[["RCUTILS_LOG_SEVERITY","The severity levels of log messages / loggers."],["_bindgen_ty_1","Default size of the rmw queue when history is set to RMW_QOS_POLICY_HISTORY_KEEP_LAST, 0 indicates it is currently not set"],["rcl_clock_change_t","Enumeration to describe the type of time jump."],["rcl_clock_type_t","Time source type, used to indicate the source of a time measurement. **"],["rcl_publisher_event_type_t",""],["rcl_subscription_event_type_t",""],["rmw_endpoint_type_t","Endpoint enumeration type"],["rmw_localhost_only_t","Used to specify if the context can only communicate through localhost."],["rmw_log_severity_t","Type mapping of rcutils log severity types to rmw specific types."],["rmw_qos_durability_policy_t","QoS durability enumerations describing how samples persist"],["rmw_qos_history_policy_t","QoS history enumerations describing how samples endure"],["rmw_qos_liveliness_policy_t","QoS liveliness enumerations that describe a publisher’s reporting policy for its alive status. For a subscriber, these are its requirements for its topic’s publishers."],["rmw_qos_policy_kind_t","QoS Policy Kinds"],["rmw_qos_reliability_policy_t",""],["rmw_security_enforcement_policy_t",""]],"fn":[["rcl_arguments_copy","Copy one arguments structure into another. **"],["rcl_arguments_fini","Reclaim resources held inside rcl_arguments_t structure. **"],["rcl_arguments_get_count_unparsed","Return the number of arguments that were not ROS specific arguments. **"],["rcl_arguments_get_count_unparsed_ros","Return the number of ROS specific arguments that were not successfully parsed. **"],["rcl_arguments_get_param_files","Return a list of yaml parameter file paths specified on the command line. **"],["rcl_arguments_get_param_files_count","Return the number of parameter yaml files given in the arguments. **"],["rcl_arguments_get_param_overrides","Return all parameter overrides parsed from the command line. **"],["rcl_arguments_get_unparsed","Return a list of indices to non ROS specific arguments. **"],["rcl_arguments_get_unparsed_ros","Return a list of indices to unknown ROS specific arguments that were left unparsed. **"],["rcl_borrow_loaned_message","Borrow a loaned message. **"],["rcl_client_fini","Finalize a rcl_client_t. **"],["rcl_client_get_default_options","Return the default client options in a rcl_client_options_t. **"],["rcl_client_get_options","Return the rcl client options. **"],["rcl_client_get_rmw_handle","Return the rmw client handle. **"],["rcl_client_get_service_name","Get the name of the service that this client will request a response from. **"],["rcl_client_init","Initialize a rcl client. **"],["rcl_client_is_valid","Check that the client is valid. **"],["rcl_clock_add_jump_callback","Add a callback to be called when a time jump exceeds a threshold. **"],["rcl_clock_fini","Finalize a clock. **"],["rcl_clock_get_now","Fill the time point value with the current value of the associated clock. **"],["rcl_clock_init","Initialize a clock based on the passed type. **"],["rcl_clock_remove_jump_callback","Remove a previously added time jump callback. **"],["rcl_clock_valid","Check if the clock has valid values. **"],["rcl_context_fini","Finalize a context. **"],["rcl_context_get_init_options","Return the init options used during initialization for this context. **"],["rcl_context_get_instance_id","Returns an unsigned integer that is unique to the given context, or `0` if invalid. **"],["rcl_context_get_rmw_context","Return pointer to the rmw context if the given context is currently valid, otherwise `NULL`. **"],["rcl_context_is_valid","Return `true` if the given context is currently valid, otherwise `false`. **"],["rcl_count_publishers","Return the number of publishers on a given topic. **"],["rcl_count_subscribers","Return the number of subscriptions on a given topic. **"],["rcl_difference_times","Compute the difference between two time points **"],["rcl_disable_ros_time_override","Disable the ROS time abstraction override. **"],["rcl_enable_ros_time_override","Enable the ROS time abstraction override. **"],["rcl_event_fini","Finalize an event."],["rcl_event_get_rmw_handle","Return the rmw event handle. **"],["rcl_get_client_names_and_types_by_node","Return a list of service client names and types associated with a node. **"],["rcl_get_default_domain_id","Determine the default domain ID, based on the environment. **"],["rcl_get_node_names","Return a list of available nodes in the ROS graph. **"],["rcl_get_node_names_with_enclaves","Return a list of available nodes in the ROS graph, including their enclave names. **"],["rcl_get_publisher_names_and_types_by_node","Return a list of topic names and types for publishers associated with a node. **"],["rcl_get_publishers_info_by_topic","Return a list of all publishers to a topic. **"],["rcl_get_service_names_and_types","Return a list of service names and their types. **"],["rcl_get_service_names_and_types_by_node","Return a list of service names and types associated with a node. **"],["rcl_get_subscriber_names_and_types_by_node","Return a list of topic names and types for subscriptions associated with a node. **"],["rcl_get_subscriptions_info_by_topic","Return a list of all subscriptions to a topic. **"],["rcl_get_topic_names_and_types","Return a list of topic names and their types. **"],["rcl_get_zero_initialized_arguments","Return a rcl_arguments_t struct with members initialized to `NULL`."],["rcl_get_zero_initialized_client","Return a rcl_client_t struct with members set to `NULL`. **"],["rcl_get_zero_initialized_context","Return a zero initialization context object."],["rcl_get_zero_initialized_event","Return a rcl_event_t struct with members set to `NULL`. **"],["rcl_get_zero_initialized_guard_condition","Return a rcl_guard_condition_t struct with members set to `NULL`."],["rcl_get_zero_initialized_init_options","Return a zero initialized rcl_init_options_t struct."],["rcl_get_zero_initialized_node","Return a rcl_node_t struct with members initialized to `NULL`."],["rcl_get_zero_initialized_publisher","Return a rcl_publisher_t struct with members set to `NULL`. **"],["rcl_get_zero_initialized_service","Return a rcl_service_t struct with members set to `NULL`. **"],["rcl_get_zero_initialized_subscription","Return a rcl_subscription_t struct with members set to `NULL`. **"],["rcl_get_zero_initialized_timer","Return a zero initialized timer."],["rcl_get_zero_initialized_wait_set","Return a rcl_wait_set_t struct with members set to `NULL`."],["rcl_guard_condition_fini","Finalize a rcl_guard_condition_t. **"],["rcl_guard_condition_get_default_options","Return the default options in a rcl_guard_condition_options_t struct. **"],["rcl_guard_condition_get_options","Return the guard condition options. **"],["rcl_guard_condition_get_rmw_handle","Return the rmw guard condition handle. **"],["rcl_guard_condition_init","Initialize a rcl guard_condition. **"],["rcl_guard_condition_init_from_rmw","Same as rcl_guard_condition_init(), but reusing an existing rmw handle. **"],["rcl_init","Initialization of rcl. **"],["rcl_init_options_copy","Copy the given source init_options to the destination init_options. **"],["rcl_init_options_fini","Finalize the given init_options. **"],["rcl_init_options_get_allocator","Return the allocator stored in the init_options. **"],["rcl_init_options_get_rmw_init_options","Return the rmw init options which are stored internally. **"],["rcl_init_options_init","Initialize given init_options with the default values and implementation specific values. **"],["rcl_is_enabled_ros_time_override","Check if the `RCL_ROS_TIME` time source has the override enabled. **"],["rcl_logging_configure","Configure the logging system. **"],["rcl_logging_configure_with_output_handler","Configure the logging system with the provided output handler. **"],["rcl_logging_fini","This function should be called to tear down the logging setup by the configure function."],["rcl_logging_multiple_output_handler","Default output handler used by rcl. **"],["rcl_logging_rosout_enabled","See if logging rosout is enabled. **"],["rcl_logging_rosout_fini","Uninitializes the rcl_logging_rosout features **"],["rcl_logging_rosout_fini_publisher_for_node","Deregisters a rosout publisher for a node and cleans up allocated resources **"],["rcl_logging_rosout_init","Initializes the rcl_logging_rosout features **"],["rcl_logging_rosout_init_publisher_for_node","Creates a rosout publisher for a node and registers it to be used by the logging system **"],["rcl_logging_rosout_output_handler","The output handler outputs log messages to rosout topics. **"],["rcl_names_and_types_fini","Finalize a rcl_names_and_types_t object. **"],["rcl_names_and_types_init","Initialize a rcl_names_and_types_t object. **"],["rcl_node_fini","Finalize a rcl_node_t. **"],["rcl_node_get_default_options","Return the default node options in a rcl_node_options_t. **"],["rcl_node_get_domain_id","Return the ROS domain ID that the node is using. **"],["rcl_node_get_fully_qualified_name","Return the fully qualified name of the node. **"],["rcl_node_get_graph_guard_condition","Return a guard condition which is triggered when the ROS graph changes. **"],["rcl_node_get_logger_name","Return the logger name of the node. **"],["rcl_node_get_name","Return the name of the node. **"],["rcl_node_get_namespace","Return the namespace of the node. **"],["rcl_node_get_options","Return the rcl node options. **"],["rcl_node_get_rcl_instance_id","Return the associated rcl instance id. **"],["rcl_node_get_rmw_handle","Return the rmw node handle. **"],["rcl_node_init","Initialize a ROS node. **"],["rcl_node_is_valid","Return `true` if the node is valid, else `false`. **"],["rcl_node_is_valid_except_context","Return true if node is valid, except for the context being valid. **"],["rcl_node_options_copy","Copy one options structure into another. **"],["rcl_node_options_fini","Finalize the given node_options. **"],["rcl_parse_arguments","Parse command line arguments into a structure usable by code. **"],["rcl_parse_yaml_file","\\brief Parse the YAML file and populate \\p params_st \\pre Given \\p params_st must be a valid parameter struct as returned by `rcl_yaml_node_struct_init()` \\param[in] file_path is the path to the YAML file \\param[inout] params_st points to the struct to be populated \\return true on success and false on failure"],["rcl_parse_yaml_value","\\brief Parse a parameter value as a YAML string, updating params_st accordingly \\param[in] node_name is the name of the node to which the parameter belongs \\param[in] param_name is the name of the parameter whose value will be parsed \\param[in] yaml_value is the parameter value as a YAML string to be parsed \\param[inout] params_st points to the parameter struct \\return true on success and false on failure"],["rcl_publish","Publish a ROS message on a topic using a publisher. **"],["rcl_publish_loaned_message","Publish a loaned message on a topic using a publisher. **"],["rcl_publish_serialized_message","Publish a serialized message on a topic using a publisher. **"],["rcl_publisher_assert_liveliness","Manually assert that this Publisher is alive (for RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_TOPIC) **"],["rcl_publisher_can_loan_messages","Check if publisher instance can loan messages. **"],["rcl_publisher_event_init","Initialize an rcl_event_t with a publisher. **"],["rcl_publisher_fini","Finalize a rcl_publisher_t. **"],["rcl_publisher_get_actual_qos","Get the actual qos settings of the publisher. **"],["rcl_publisher_get_context","Return the context associated with this publisher. **"],["rcl_publisher_get_default_options","Return the default publisher options in a rcl_publisher_options_t. **"],["rcl_publisher_get_options","Return the rcl publisher options. **"],["rcl_publisher_get_rmw_handle","Return the rmw publisher handle. **"],["rcl_publisher_get_subscription_count","Get the number of subscriptions matched to a publisher. **"],["rcl_publisher_get_topic_name","Get the topic name for the publisher. **"],["rcl_publisher_init","Initialize a rcl publisher. **"],["rcl_publisher_is_valid","Return true if the publisher is valid, otherwise false. **"],["rcl_publisher_is_valid_except_context","Return true if the publisher is valid except the context, otherwise false. **"],["rcl_remove_ros_arguments","Return a list of arguments with ROS-specific arguments removed. **"],["rcl_return_loaned_message_from_publisher","Return a loaned message previously borrowed from a publisher. **"],["rcl_return_loaned_message_from_subscription","Return a loaned message from a topic using a rcl subscription. **"],["rcl_ros_clock_fini","Finalize a clock as a `RCL_ROS_TIME` time source. **"],["rcl_ros_clock_init","Initialize a clock as a RCL_ROS_TIME time source. **"],["rcl_send_request","Send a ROS request using a client. **"],["rcl_send_response","Send a ROS response to a client using a service. **"],["rcl_service_fini","Finalize a rcl_service_t. **"],["rcl_service_get_default_options","Return the default service options in a rcl_service_options_t. **"],["rcl_service_get_options","Return the rcl service options. **"],["rcl_service_get_rmw_handle","Return the rmw service handle. **"],["rcl_service_get_service_name","Get the topic name for the service. **"],["rcl_service_init","Initialize a rcl service. **"],["rcl_service_is_valid","Check that the service is valid. **"],["rcl_service_server_is_available","Check if a service server is available for the given service client. **"],["rcl_set_ros_time_override","Set the current time for this `RCL_ROS_TIME` time source. **"],["rcl_shutdown","Shutdown a given rcl context. **"],["rcl_steady_clock_fini","Finalize a clock as a `RCL_STEADY_TIME` time source. **"],["rcl_steady_clock_init","Initialize a clock as a `RCL_STEADY_TIME` time source. **"],["rcl_subscription_can_loan_messages","Check if subscription instance can loan messages. **"],["rcl_subscription_event_init","Initialize an rcl_event_t with a subscription. **"],["rcl_subscription_fini","Finalize a rcl_subscription_t. **"],["rcl_subscription_get_actual_qos","Get the actual qos settings of the subscription. **"],["rcl_subscription_get_default_options","Return the default subscription options in a rcl_subscription_options_t. **"],["rcl_subscription_get_options","Return the rcl subscription options. **"],["rcl_subscription_get_publisher_count","Get the number of publishers matched to a subscription. **"],["rcl_subscription_get_rmw_handle","Return the rmw subscription handle. **"],["rcl_subscription_get_topic_name","Get the topic name for the subscription. **"],["rcl_subscription_init","Initialize a ROS subscription. **"],["rcl_subscription_is_valid","Check that the subscription is valid. **"],["rcl_system_clock_fini","Finalize a clock as a `RCL_SYSTEM_TIME` time source. **"],["rcl_system_clock_init","Initialize a clock as a `RCL_SYSTEM_TIME` time source. **"],["rcl_take","Take a ROS message from a topic using a rcl subscription. **"],["rcl_take_event","Take an event from the event handle."],["rcl_take_loaned_message","Take a loaned message from a topic using a rcl subscription. **"],["rcl_take_request","backwards compatibility version that takes a request_id only"],["rcl_take_request_with_info","Take a pending ROS request using a rcl service. **"],["rcl_take_response","backwards compatibility function that takes a rmw_request_id_t only"],["rcl_take_response_with_info","Take a ROS response using a client **"],["rcl_take_sequence","Take a sequence of messages from a topic using a rcl subscription. **"],["rcl_take_serialized_message","Take a serialized raw message from a topic using a rcl subscription. **"],["rcl_timer_call","Call the timer’s callback and set the last call time. **"],["rcl_timer_cancel","Cancel a timer. **"],["rcl_timer_clock","Retrieve the clock of the timer. **"],["rcl_timer_exchange_callback","Exchange the current timer callback and return the current callback. **"],["rcl_timer_exchange_period","Exchange the period of the timer and return the previous period. **"],["rcl_timer_fini","Finalize a timer. **"],["rcl_timer_get_allocator","Return the allocator for the timer. **"],["rcl_timer_get_callback","Return the current timer callback. **"],["rcl_timer_get_guard_condition","Retrieve a guard condition used by the timer to wake the waitset when using ROSTime. **"],["rcl_timer_get_period","Retrieve the period of the timer. **"],["rcl_timer_get_time_since_last_call","Retrieve the time since the previous call to rcl_timer_call() occurred. **"],["rcl_timer_get_time_until_next_call","Calculate and retrieve the time until the next call in nanoseconds. **"],["rcl_timer_init","Initialize a timer. **"],["rcl_timer_is_canceled","Retrieve the canceled state of a timer. **"],["rcl_timer_is_ready","Calculates whether or not the timer should be called. **"],["rcl_timer_reset","Reset a timer. **"],["rcl_trigger_guard_condition","Trigger a rcl guard condition. **"],["rcl_wait","Block until the wait set is ready or until the timeout has been exceeded. **"],["rcl_wait_set_add_client","Store a pointer to the client in the next empty spot in the set. **"],["rcl_wait_set_add_event","Store a pointer to the event in the next empty spot in the set. **"],["rcl_wait_set_add_guard_condition","Store a pointer to the guard condition in the next empty spot in the set. **"],["rcl_wait_set_add_service","Store a pointer to the service in the next empty spot in the set. **"],["rcl_wait_set_add_subscription","Store a pointer to the given subscription in the next empty spot in the set. **"],["rcl_wait_set_add_timer","Store a pointer to the timer in the next empty spot in the set. **"],["rcl_wait_set_clear","Remove (sets to `NULL`) all entities in the wait set. **"],["rcl_wait_set_fini","Finalize a rcl wait set. **"],["rcl_wait_set_get_allocator","Retrieve the wait set’s allocator. **"],["rcl_wait_set_init","Initialize a rcl wait set with space for items to be waited on. **"],["rcl_wait_set_is_valid","Return `true` if the wait set is valid, else `false`. **"],["rcl_wait_set_resize","Reallocate space for entities in the wait set. **"],["rcl_yaml_node_struct_copy","\\brief Copy parameter structure \\param[in] params_st points to the parameter struct to be copied \\return a pointer to the copied param structure on success or NULL on failure"],["rcl_yaml_node_struct_fini","\\brief Free parameter structure \\param[in] params_st points to the populated parameter struct"],["rcl_yaml_node_struct_get","\\brief Get the variant value for a given parameter, zero initializing it in the process if not present already \\param[in] node_name is the name of the node to which the parameter belongs \\param[in] param_name is the name of the parameter whose value is to be retrieved \\param[inout] params_st points to the populated (or to be populated) parameter struct \\return parameter variant value on success and NULL on failure"],["rcl_yaml_node_struct_init","\\brief Initialize parameter structure \\param[in] allocator memory allocator to be used \\return a pointer to param structure on success or NULL on failure"],["rcl_yaml_node_struct_print","\\brief Print the parameter structure to stdout \\param[in] params_st points to the populated parameter struct"],["rcutils_allocator_is_valid","Return true if the given allocator has non-null function pointers. **"],["rcutils_array_list_add","Adds an entry to the list **"],["rcutils_array_list_fini","Finalize an array list, reclaiming all resources. **"],["rcutils_array_list_get","Retrieves an entry in the list at the provided index **"],["rcutils_array_list_get_size","Retrieves the size of the provided array_list **"],["rcutils_array_list_init","Initialize an array list with a given initial capacity. **"],["rcutils_array_list_remove","Removes an entry in the list at the provided index **"],["rcutils_array_list_set","Sets an entry in the list to the provided data **"],["rcutils_char_array_expand_as_needed","Expand the internal buffer of the char array. **"],["rcutils_char_array_fini","Finalize a char array struct. **"],["rcutils_char_array_init","Initialize a zero initialized char array struct. **"],["rcutils_char_array_memcpy","Copy memory to buffer. **"],["rcutils_char_array_resize","Resize the internal buffer of the char array. **"],["rcutils_char_array_strcat","Append a string to the string in buffer. **"],["rcutils_char_array_strcpy","Copy a string to buffer. **"],["rcutils_char_array_strncat","Append a string (or part of it) to the string in buffer. **"],["rcutils_char_array_vsprintf","Produce output according to format and args. **"],["rcutils_error_is_set","Return `true` if the error is set, otherwise `false`."],["rcutils_fault_injection_get_count","\\brief Atomically get the fault injection counter value"],["rcutils_fault_injection_is_test_complete",""],["rcutils_fault_injection_set_count","\\brief Atomically set the fault injection counter."],["rcutils_get_default_allocator","Return a properly initialized rcutils_allocator_t with default values. **"],["rcutils_get_error_state","Return an rcutils_error_state_t which was set with rcutils_set_error_state(). **"],["rcutils_get_error_string","Return the error message followed by `, at <file>:<line>` if set, else “error not set”. **"],["rcutils_get_zero_initialized_allocator","Return a zero initialized allocator. **"],["rcutils_get_zero_initialized_array_list","Return an empty array_list struct. **"],["rcutils_get_zero_initialized_char_array","Return a zero initialized char array struct. **"],["rcutils_get_zero_initialized_hash_map",""],["rcutils_get_zero_initialized_string_array","Return an empty string array struct. **"],["rcutils_get_zero_initialized_string_map",""],["rcutils_get_zero_initialized_uint8_array","Return a zero initialized uint8 array struct. **"],["rcutils_hash_map_fini","Finalize the previously initialized hash_map struct. **"],["rcutils_hash_map_get","Get value given a key. **"],["rcutils_hash_map_get_capacity","Get the current capacity of the hash_map. **"],["rcutils_hash_map_get_next_key_and_data","Get the next key in the hash_map, unless NULL is given, then get the first key. **"],["rcutils_hash_map_get_size","Get the current size of the hash_map. **"],["rcutils_hash_map_init","Initialize a rcutils_hash_map_t, allocating space for given capacity. **"],["rcutils_hash_map_key_exists","Get whether or not a key exists. **"],["rcutils_hash_map_set","Set a key value pair in the hash_map, increasing capacity if necessary. **"],["rcutils_hash_map_string_cmp_func","A comparison function for a null terminated c string. **"],["rcutils_hash_map_string_hash_func","A hashing function for a null terminated c string. **"],["rcutils_hash_map_unset","Unset a key value pair in the hash_map. **"],["rcutils_initialize_error_handling_thread_local_storage","Forces initialization of thread-local storage if called in a newly created thread. **"],["rcutils_log","Log a message. **"],["rcutils_logging_console_output_handler","The default output handler outputs log messages to the standard streams. **"],["rcutils_logging_format_message","Formats a log message according to RCUTILS_CONSOLE_OUTPUT_FORMAT **"],["rcutils_logging_get_default_logger_level","Get the default level for loggers. **"],["rcutils_logging_get_logger_effective_level","Determine the effective level for a logger. **"],["rcutils_logging_get_logger_level","Get the severity level for a logger. **"],["rcutils_logging_get_logger_leveln","Get the level for a logger and its name length. **"],["rcutils_logging_get_output_handler","Get the current output handler. **"],["rcutils_logging_initialize","Initialize the logging system. **"],["rcutils_logging_initialize_with_allocator","Initialize the logging system using the specified allocator. **"],["rcutils_logging_logger_is_enabled_for","Determine if a logger is enabled for a severity level. **"],["rcutils_logging_set_default_logger_level","Set the default severity level for loggers. **"],["rcutils_logging_set_logger_level","Set the severity level for a logger. **"],["rcutils_logging_set_output_handler","Set the current output handler. **"],["rcutils_logging_severity_level_from_string","Get a severity value from its string representation (e.g. DEBUG). **"],["rcutils_logging_shutdown","Shutdown the logging system. **"],["rcutils_qsort","Interface to qsort with rcutils-style argument validation. **"],["rcutils_reallocf","Emulate the behavior of reallocf. **"],["rcutils_reset_error","Reset the error state by clearing any previously set error state."],["rcutils_set_error_state","Set the error message, as well as the file and line on which it occurred. **"],["rcutils_snprintf","Format a string. **"],["rcutils_steady_time_now","Retrieve the current time as a rcutils_time_point_value_t object. **"],["rcutils_string_array_cmp","Compare two string arrays. **"],["rcutils_string_array_fini","Finalize a string array, reclaiming all resources. **"],["rcutils_string_array_init","Initialize a string array with a given size. **"],["rcutils_string_array_resize","Resize a string array, reclaiming removed resources. **"],["rcutils_string_array_sort_compare","Lexicographic comparer for pointers to string pointers. **"],["rcutils_string_map_clear","Remove all key value pairs from the map. **"],["rcutils_string_map_copy","Copy all the key value pairs from one map into another, overwritting and resizing if needed. **"],["rcutils_string_map_fini","Finalize the previously initialized string map struct. **"],["rcutils_string_map_get","Get value given a key. **"],["rcutils_string_map_get_capacity","Get the current capacity of the string map. **"],["rcutils_string_map_get_next_key","Get the next key in the map, unless NULL is given, then get the first key. **"],["rcutils_string_map_get_size","Get the current size of the string map. **"],["rcutils_string_map_getn","Get value given a key and key length. **"],["rcutils_string_map_init","Initialize a rcutils_string_map_t, allocating space for given capacity. **"],["rcutils_string_map_key_exists","Get whether or not a key exists. **"],["rcutils_string_map_key_existsn","Get whether or not a key of known length exists. **"],["rcutils_string_map_reserve","Reserve a given amount of capacity in the map. **"],["rcutils_string_map_set","Set a key value pair in the map, increasing capacity if necessary. **"],["rcutils_string_map_set_no_resize","Set a key value pair in the map but only if the map has enough capacity. **"],["rcutils_string_map_unset","Unset a key value pair in the map. **"],["rcutils_system_time_now","This function returns the time from a system clock. The closest equivalent would be to std::chrono::system_clock::now();"],["rcutils_time_point_value_as_nanoseconds_string","Return a time point as nanoseconds in a string. **"],["rcutils_time_point_value_as_seconds_string","Return a time point as floating point seconds in a string. **"],["rcutils_uint8_array_fini","Finalize a uint8 array struct. **"],["rcutils_uint8_array_init","Initialize a zero initialized uint8 array struct. **"],["rcutils_uint8_array_resize","Resize the internal buffer of the uint8 array. **"],["rcutils_vsnprintf","Format a string with va_list for arguments, see rcutils_snprintf()."],["rmw_borrow_loaned_message","Borrow a loaned ROS message. **"],["rmw_compare_gids_equal","Check if two unique identifiers (gids) are equal. **"],["rmw_context_fini","Finalize a context. **"],["rmw_count_publishers","Count the number of known publishers matching a topic name. **"],["rmw_count_subscribers","Count the number of known subscribers matching a topic name. **"],["rmw_create_client","Create a service client that can send requests to and receive replies from a service server. **"],["rmw_create_guard_condition","Create a guard condition and return a handle to that guard condition. **"],["rmw_create_node","Create a node and return a handle to that node. **"],["rmw_create_publisher","Create a publisher and return a handle to that publisher. **"],["rmw_create_service","Create a service server that can receive requests from and send replies to a service client. **"],["rmw_create_subscription","Create a subscription and return a handle to that subscription. **"],["rmw_create_wait_set","Create a wait set to store conditions that the middleware can wait on. **"],["rmw_deserialize","Deserialize a ROS message. **"],["rmw_destroy_client","Destroy and unregister a service client from its node. **"],["rmw_destroy_guard_condition","Finalize a given guard condition handle, reclaim the resources, and deallocate the handle. **"],["rmw_destroy_node","Finalize a given node handle, reclaim the resources, and deallocate the node handle. **"],["rmw_destroy_publisher","Finalize a given publisher handle, reclaim the resources, and deallocate the publisher handle. **"],["rmw_destroy_service","Destroy and unregister a service server from its node. **"],["rmw_destroy_subscription","Finalize a given subscription handle, reclaim the resources, and deallocate the subscription handle. **"],["rmw_destroy_wait_set","Destroy a wait set. **"],["rmw_fini_publisher_allocation","Destroy a publisher allocation object. **"],["rmw_fini_subscription_allocation","Destroy a publisher allocation object. **"],["rmw_get_default_publisher_options","Return a rmw_publisher_options_t initialized with default values."],["rmw_get_default_security_options","Get default initialized security options."],["rmw_get_default_subscription_options","Return a rmw_subscription_options_t initialized with default values."],["rmw_get_gid_for_publisher","Get the unique identifier (gid) of a publisher. **"],["rmw_get_implementation_identifier","Get the name of the rmw implementation being used **"],["rmw_get_node_names","Return the name and namespace of all nodes in the ROS graph. **"],["rmw_get_node_names_with_enclaves","Return the name, namespae, and enclave name of all nodes in the ROS graph. **"],["rmw_get_serialization_format","Get the unique serialization format for this middleware. **"],["rmw_get_serialized_message_size","Compute the size of a serialized message. **"],["rmw_get_topic_names_and_types","Return all topic names and types in the ROS graph. **"],["rmw_get_zero_initialized_context","Return a zero initialized context structure."],["rmw_get_zero_initialized_init_options","Return a zero initialized init options structure."],["rmw_get_zero_initialized_message_info","Get zero initialized mesage info."],["rmw_get_zero_initialized_message_info_sequence","Return an rmw_message_info_sequence_t struct with members initialized to `NULL`"],["rmw_get_zero_initialized_message_sequence","Return an rmw_message_sequence_t struct with members initialized to `NULL`"],["rmw_get_zero_initialized_names_and_types","Return a zero initialized array of names and types."],["rmw_get_zero_initialized_security_options","Get zero initialized security options."],["rmw_get_zero_initialized_topic_endpoint_info","Return zero initialized topic endpoint info data structure. **"],["rmw_get_zero_initialized_topic_endpoint_info_array","Return a zero initialized array of topic endpoint information."],["rmw_init","Initialize the middleware with the given options, and yielding an context. **"],["rmw_init_options_copy","Copy the given source init options to the destination init options. **"],["rmw_init_options_fini","Finalize the given init options. **"],["rmw_init_options_init","Initialize given init options with the default values and implementation specific values. **"],["rmw_init_publisher_allocation","Initialize a publisher allocation to be used with later publications. **"],["rmw_init_subscription_allocation","Initialize a subscription allocation to be used with later `take`s. **"],["rmw_message_info_sequence_fini","Finalize an rmw_message_sequence_t object. **"],["rmw_message_info_sequence_init","Initialize an rmw_message_info_sequence_t object. **"],["rmw_message_sequence_fini","Finalize an rmw_message_sequence_t object. **"],["rmw_message_sequence_init","Initialize an rmw_message_sequence_t object. **"],["rmw_names_and_types_check_zero","Check that the given `names_and_types` array is zero initialized. **"],["rmw_names_and_types_fini","Finalize an array of names and types. **"],["rmw_names_and_types_init","Initialize an array of names and types. **"],["rmw_node_assert_liveliness",""],["rmw_node_get_graph_guard_condition","Return a guard condition which is triggered when the ROS graph changes. **"],["rmw_publish","Publish a ROS message. **"],["rmw_publish_loaned_message","Publish a loaned ROS message. **"],["rmw_publish_serialized_message","Publish a ROS message as a byte stream. **"],["rmw_publisher_assert_liveliness","Manually assert that this Publisher is alive (for RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_TOPIC) **"],["rmw_publisher_count_matched_subscriptions","Retrieve the number of matched subscriptions to a publisher. **"],["rmw_publisher_get_actual_qos","Retrieve the actual qos settings of the publisher. **"],["rmw_return_loaned_message_from_publisher","Return a loaned message previously borrowed from a publisher. **"],["rmw_return_loaned_message_from_subscription","Return a loaned ROS message previously taken from a subscription. **"],["rmw_security_options_copy","Copy the given security options. **"],["rmw_security_options_fini","Finalize the given security_options. **"],["rmw_security_options_set_root_path","Set the security root path for the given security options. **"],["rmw_send_request","Send a ROS service request. **"],["rmw_send_response","Send a ROS service response. **"],["rmw_serialize","Serialize a ROS message into a rmw_serialized_message_t. **"],["rmw_service_server_is_available","Check if a service server is available for the given service client. **"],["rmw_set_log_severity","Set the current log severity **"],["rmw_shutdown","Shutdown the middleware for a given context. **"],["rmw_subscription_count_matched_publishers","Retrieve the number of matched publishers to a subscription. **"],["rmw_subscription_get_actual_qos","Retrieve the actual qos settings of the subscription. **"],["rmw_take","Take an incoming ROS message. **"],["rmw_take_loaned_message","Take an incoming ROS message, loaned by the middleware. **"],["rmw_take_loaned_message_with_info","Take a loaned message and with its additional message information. **"],["rmw_take_request","Take an incoming ROS service request. **"],["rmw_take_response","Take an incoming ROS service response. **"],["rmw_take_sequence","Take multiple incoming ROS messages with their metadata. **"],["rmw_take_serialized_message","Take an incoming ROS message as a byte stream. **"],["rmw_take_serialized_message_with_info","Take an incoming ROS message as a byte stream with its metadata. **"],["rmw_take_with_info","Take an incoming ROS message with its metadata. **"],["rmw_topic_endpoint_info_array_check_zero","Check that the given `topic_endpoint_info_array` is zero initialized. **"],["rmw_topic_endpoint_info_array_fini","Finalize an array of topic endpoint information. **"],["rmw_topic_endpoint_info_array_init_with_size","Initialize an array of topic endpoint information. **"],["rmw_topic_endpoint_info_fini","Finalize a topic endpoint info data structure. **"],["rmw_topic_endpoint_info_set_endpoint_type","Set the endpoint type in the given topic endpoint info data structure. **"],["rmw_topic_endpoint_info_set_gid","Set the endpoint gid in the given topic endpoint info data structure. **"],["rmw_topic_endpoint_info_set_node_name","Set the node name in the given topic endpoint info data structure. **"],["rmw_topic_endpoint_info_set_node_namespace","Set the node namespace in the given topic endpoint info data structure. **"],["rmw_topic_endpoint_info_set_qos_profile","Set the endpoint QoS profile in the given topic endpoint info data structure. **"],["rmw_topic_endpoint_info_set_topic_type","Set the topic type in the given topic endpoint info data structure. **"],["rmw_trigger_guard_condition",""],["rmw_wait","Waits on sets of different entities and returns when one is ready. **"]],"static":[["RCL_DOMAIN_ID_ENV_VAR",""],["g_rcutils_log_severity_names","The names of severity levels."],["g_rcutils_logging_default_logger_level","The default severity level for loggers. **"],["g_rcutils_logging_initialized","The flag if the logging system has been initialized."],["g_rcutils_logging_output_handler","The function pointer of the current output handler."]],"struct":[["__va_list_tag",""],["rcl_arguments_impl_t",""],["rcl_arguments_t","Hold output of parsing command line arguments."],["rcl_bool_array_s","Array of bool values"],["rcl_byte_array_s","Array of byte values"],["rcl_client_impl_t","Internal rcl client implementation struct."],["rcl_client_options_t","Options available for a rcl_client_t."],["rcl_client_t","Structure which encapsulates a ROS Client."],["rcl_clock_t","Encapsulation of a time source."],["rcl_context_impl_t",""],["rcl_context_t","Encapsulates the non-global state of an init/shutdown cycle. **"],["rcl_double_array_s","Array of double values"],["rcl_duration_t","A duration of time, measured in nanoseconds and its source."],["rcl_event_impl_t","Internal rcl implementation struct."],["rcl_event_t","Structure which encapsulates a ROS QoS event handle."],["rcl_guard_condition_impl_t","Internal rcl guard condition implementation struct."],["rcl_guard_condition_options_t","Options available for a rcl guard condition."],["rcl_guard_condition_t","Handle for a rcl guard condition."],["rcl_init_options_impl_t",""],["rcl_init_options_t","Encapsulation of init options and implementation defined init options."],["rcl_int64_array_s","Array of int64_t values"],["rcl_jump_callback_info_t","Struct to describe an added callback."],["rcl_jump_threshold_t","Describe the prerequisites for calling a time jump callback."],["rcl_node_impl_t",""],["rcl_node_options_t","Structure which encapsulates the options for creating a rcl_node_t."],["rcl_node_params_s","node_params_t stores all the parameters(key:value) of a single node"],["rcl_node_t","Structure which encapsulates a ROS Node."],["rcl_params_s","stores all the parameters of all nodes of a process"],["rcl_publisher_impl_t","Internal rcl publisher implementation struct."],["rcl_publisher_options_t","Options available for a rcl publisher."],["rcl_publisher_t","Structure which encapsulates a ROS Publisher."],["rcl_service_impl_t","Internal rcl implementation struct."],["rcl_service_options_t","Options available for a rcl service."],["rcl_service_t","Structure which encapsulates a ROS Service."],["rcl_subscription_impl_t","Internal rcl implementation struct."],["rcl_subscription_options_t","Options available for a rcl subscription."],["rcl_subscription_t","Structure which encapsulates a ROS Subscription."],["rcl_time_jump_t","Struct to describe a jump in time."],["rcl_time_point_t","A single point in time, measured in nanoseconds, the reference point is based on the source."],["rcl_timer_impl_t",""],["rcl_timer_t","Structure which encapsulates a ROS Timer."],["rcl_variant_s","variant_t stores the value of a parameter"],["rcl_wait_set_impl_t",""],["rcl_wait_set_t","Container for subscription’s, guard condition’s, etc to be waited on."],["rcutils_allocator_t","Encapsulation of an allocator. **"],["rcutils_array_list_impl_t",""],["rcutils_array_list_t",""],["rcutils_char_array_t",""],["rcutils_error_state_t","Struct which encapsulates the error state set by RCUTILS_SET_ERROR_MSG()."],["rcutils_error_string_t","Struct wrapping a fixed-size c string used for returning the formatted error string."],["rcutils_hash_map_impl_t",""],["rcutils_hash_map_t",""],["rcutils_log_location_t","The structure identifying the caller location in the source code."],["rcutils_string_array_t",""],["rcutils_string_map_impl_t",""],["rcutils_string_map_t",""],["rcutils_uint8_array_t",""],["rmw_client_t","A handle to an rmw service client"],["rmw_clients_t","Array of client handles. **"],["rmw_context_impl_t",""],["rmw_context_t","Initialization context structure which is used to store init specific information."],["rmw_event_t",""],["rmw_events_t",""],["rmw_gid_t","ROS graph ID of the topic"],["rmw_guard_condition_t","Handle for an rmw guard condition"],["rmw_guard_conditions_t","Array of guard condition handles. **"],["rmw_init_options_impl_t",""],["rmw_init_options_t","Options structure used during rmw_init()."],["rmw_liveliness_changed_status_t","QoS Liveliness Changed information provided by a subscription."],["rmw_liveliness_lost_status_t","QoS Liveliness Lost information provided by a publisher."],["rmw_message_info_sequence_t","Structure to hold a sequence of message infos."],["rmw_message_info_t","Information describing an rmw message"],["rmw_message_sequence_t","Structure to hold a sequence of ROS messages."],["rmw_names_and_types_t","Associative array of topic or service names and types."],["rmw_node_t","Structure which encapsulates an rmw node"],["rmw_offered_deadline_missed_status_t","QoS Deadline Missed information provided by a publisher."],["rmw_publisher_allocation_t","Allocation of memory for an rmw publisher"],["rmw_publisher_options_t","Options that can be used to configure the creation of a publisher in rmw."],["rmw_publisher_t","Structure which encapsulates an rmw publisher"],["rmw_qos_incompatible_event_status_t",""],["rmw_qos_profile_t","ROS MiddleWare quality of service profile."],["rmw_request_id_t","An rmw service request identifier"],["rmw_requested_deadline_missed_status_t","QoS Requested Deadline Missed information provided by a subscription."],["rmw_security_options_t",""],["rmw_service_info_t","Meta-data for a service-related take."],["rmw_service_t","A handle to an rmw service"],["rmw_services_t","Array of service handles. **"],["rmw_subscription_allocation_t","Allocation of memory for an rmw subscription"],["rmw_subscription_options_t","Options that can be used to configure the creation of a subscription in rmw."],["rmw_subscription_t",""],["rmw_subscriptions_t","Array of subscriber handles. **"],["rmw_time_t","Struct representing a time point for rmw"],["rmw_topic_endpoint_info_array_t","Array of topic endpoint information"],["rmw_topic_endpoint_info_t","A data structure that encapsulates the node name, node namespace, topic_type, gid, and qos_profile of publishers and subscriptions for a topic."],["rmw_wait_set_t","Container for guard conditions to be waited on"],["rosidl_message_type_support_t","Contains rosidl message type support data"],["rosidl_runtime_c__Sequence__bound",""],["rosidl_service_type_support_t","Contains rosidl service type support data"]],"type":[["__builtin_va_list",""],["__int32_t",""],["__int64_t",""],["__int8_t",""],["__int_least64_t",""],["__uint64_t",""],["__uint8_t",""],["int_least64_t",""],["rcl_allocator_t",""],["rcl_bool_array_t","Array of bool values"],["rcl_byte_array_t","Array of byte values"],["rcl_context_instance_id_t",""],["rcl_double_array_t","Array of double values"],["rcl_duration_value_t","A duration of time, measured in nanoseconds."],["rcl_error_state_t","The error handling in RCL is just an alias to the error handling in rcutils."],["rcl_error_string_t",""],["rcl_int64_array_t","Array of int64_t values"],["rcl_jump_callback_t","Signature of a time jump callback. \\param[in] time_jump A description of the jump in time. \\param[in] before_jump Every jump callback is called twice: once before the clock changes and once after. This is true the first call and false the second. \\param[in] user_data A pointer given at callback registration which is passed to the callback."],["rcl_logging_output_handler_t",""],["rcl_names_and_types_t",""],["rcl_node_params_t","node_params_t stores all the parameters(key:value) of a single node"],["rcl_params_t","stores all the parameters of all nodes of a process"],["rcl_ret_t",""],["rcl_serialized_message_t","typedef for rmw_serialized_message_t;"],["rcl_time_point_value_t","A single point in time, measured in nanoseconds since the Unix epoch."],["rcl_timer_callback_t","User callback signature for timers. **"],["rcl_topic_endpoint_info_array_t",""],["rcl_topic_endpoint_info_t",""],["rcl_variant_t","variant_t stores the value of a parameter"],["rcutils_duration_value_t","A duration of time, measured in nanoseconds."],["rcutils_hash_map_key_cmp_t","The function signature for a key comparison function. **"],["rcutils_hash_map_key_hasher_t","The function signature for a key hashing function. **"],["rcutils_logging_output_handler_t","The function signature to log messages. **"],["rcutils_ret_t",""],["rcutils_time_point_value_t","A single point in time, measured in nanoseconds since the Unix epoch."],["rmw_offered_qos_incompatible_event_status_t","Event state for a publisher’s ‘RMW_EVENT_OFFERED_QOS_INCOMPATIBLE’ events."],["rmw_requested_qos_incompatible_event_status_t","Event state for a subscription’s ‘RMW_EVENT_REQUESTED_QOS_INCOMPATIBLE’ events."],["rmw_ret_t","Return code for rmw functions"],["rmw_serialized_message_t","\\struct rmw_serialized_message_t"],["rmw_time_point_value_t",""],["rosidl_message_typesupport_handle_function",""],["rosidl_runtime_c__bound_handle_function",""],["rosidl_service_typesupport_handle_function",""],["va_list",""]]});