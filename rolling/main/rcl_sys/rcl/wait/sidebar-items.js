initSidebarItems({"fn":[["rcl_get_zero_initialized_wait_set","Return a [rcl_wait_set_t] struct with members set to `NULL`."],["rcl_wait","Block until the wait set is ready or until the timeout has been exceeded."],["rcl_wait_set_add_client","Store a pointer to the client in the next empty spot in the set."],["rcl_wait_set_add_event","Store a pointer to the event in the next empty spot in the set."],["rcl_wait_set_add_guard_condition","Store a pointer to the guard condition in the next empty spot in the set."],["rcl_wait_set_add_service","Store a pointer to the service in the next empty spot in the set."],["rcl_wait_set_add_subscription","Store a pointer to the given subscription in the next empty spot in the set."],["rcl_wait_set_add_timer","Store a pointer to the timer in the next empty spot in the set."],["rcl_wait_set_clear","Remove (sets to `NULL`) all entities in the wait set."],["rcl_wait_set_fini","Finalize a rcl wait set."],["rcl_wait_set_get_allocator","Retrieve the wait set’s allocator."],["rcl_wait_set_init","Initialize a rcl wait set with space for items to be waited on."],["rcl_wait_set_is_valid","Return `true` if the wait set is valid, else `false`."],["rcl_wait_set_resize","Reallocate space for entities in the wait set."]],"struct":[["rcl_wait_set_t","Container for subscription’s, guard condition’s, etc to be waited on."]]});